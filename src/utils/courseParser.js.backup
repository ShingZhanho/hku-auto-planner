/**
 * Parse and process course data from the timetable
 */

/**
 * Check if a course code is a full year course (ends with FY)
 */
export const isFullYearCourse = (courseCode) => {
  return courseCode && courseCode.trim().endsWith('FY');
};

/**
 * Check if the term is a summer semester
 */
export const isSummerSemester = (term) => {
  return term && (term.toLowerCase().includes('summer') || term.toLowerCase().includes('sum sem'));
};

/**
 * Check if the career is undergraduate
 */
export const isUndergraduate = (career) => {
  return career === 'UG' || career === 'UGME' || career === 'UGDE';
};

/**
 * Parse time string (HH:MM:SS or HH:MM) or Date object to minutes from midnight
 */
export const timeToMinutes = (timeStr) => {
  if (!timeStr) return null;
  
  // If it's a Date object (from Excel), extract time using UTC to avoid timezone issues
  if (timeStr instanceof Date) {
    const hours = timeStr.getUTCHours();
    const minutes = timeStr.getUTCMinutes();
    return hours * 60 + minutes;
  }
  
  // If it's a string, parse it
  const timeString = String(timeStr).trim();
  const parts = timeString.split(':');
  if (parts.length < 2) return null;
  const hours = parseInt(parts[0], 10);
  const minutes = parseInt(parts[1], 10);
  if (isNaN(hours) || isNaN(minutes)) return null;
  return hours * 60 + minutes;
};

/**
 * Format minutes to HH:MM
 */
export const minutesToTime = (minutes) => {
  const hours = Math.floor(minutes / 60);
  const mins = minutes % 60;
  return `${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}`;
};

/**
 * Format time string to HH:MM
 */
export const formatTime = (timeStr) => {
  if (!timeStr) return '';
  
  // If it's a Date object, format it
  if (timeStr instanceof Date) {
    const hours = timeStr.getHours();
    const minutes = timeStr.getMinutes();
    return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
  }
  
  // If it's already a string in HH:MM format, return it
  if (typeof timeStr === 'string' && timeStr.includes(':')) {
    const parts = timeStr.split(':');
    if (parts.length >= 2) {
      return `${parts[0].padStart(2, '0')}:${parts[1].padStart(2, '0')}`;
    }
  }
  
  // Try to convert to minutes and back
  const minutes = timeToMinutes(timeStr);
  if (minutes === null) return String(timeStr);
  return minutesToTime(minutes);
};

/**
 * Parse a single row from the CSV/JSON data
 */
export const parseClassSession = (row) => {
  return {
    term: row['TERM'],
    career: row['ACAD_CAREER'] || row[' ACAD_CAREER'],
    courseCode: row['COURSE CODE'] || row[' COURSE CODE'],
    classSection: row['CLASS SECTION'] || row[' CLASS SECTION'],
    classNumber: row['CLASS NUMBER'] || row[' CLASS NUMBER'],
    startDate: row['START DATE'] || row[' START DATE'],
    endDate: row['END DATE'] || row[' END DATE'],
    days: {
      mon: row['MON'] || row[' MON'] || '',
      tue: row['TUE'] || row[' TUE'] || '',
      wed: row['WED'] || row[' WED'] || '',
      thu: row['THU'] || row[' THU'] || '',
      fri: row['FRI'] || row[' FRI'] || '',
      sat: row['SAT'] || row[' SAT'] || '',
      sun: row['SUN'] || row[' SUN'] || '',
    },
    venue: row['VENUE'] || row[' VENUE'],
    startTime: row['START TIME'] || row[' START TIME'],
    endTime: row['END TIME'] || row[' END TIME'],
    courseTitle: row['COURSE TITLE'] || row[' COURSE TITLE'],
    offerDept: row['OFFER DEPT'] || row[' OFFER DEPT'],
    instructor: row['INSTRUCTOR'] || row[' INSTRUCTOR'],
  };
};

/**
 * Filter courses based on requirements
 */
export const filterCourses = (data) => {
  return data.filter(row => {
    const career = row['ACAD_CAREER'] || row[' ACAD_CAREER'];
    const courseCode = row['COURSE CODE'] || row[' COURSE CODE'];
    const term = row['TERM'];
    
    // Only undergraduate courses
    if (!isUndergraduate(career)) return false;
    
    // No summer semester
    if (isSummerSemester(term)) return false;
    
    // No full year courses
    if (isFullYearCourse(courseCode)) return false;
    
    return true;
  });
};

/**
 * Group sessions by course code and section
 */
export const groupByCourseAndSection = (filteredData) => {
  const grouped = {};
  
  filteredData.forEach(row => {
    const courseCode = row['COURSE CODE'] || row[' COURSE CODE'];
    const section = row['CLASS SECTION'] || row[' CLASS SECTION'];
    
    if (!courseCode) return;
    
    const key = `${courseCode}`;
    
    if (!grouped[key]) {
      grouped[key] = {
        courseCode,
        courseTitle: row['COURSE TITLE'] || row[' COURSE TITLE'],
        offerDept: row['OFFER DEPT'] || row[' OFFER DEPT'],
        term: row['TERM'],
        sections: {}
      };
    }
    
    if (!grouped[key].sections[section]) {
      grouped[key].sections[section] = [];
    }
    
    grouped[key].sections[section].push(parseClassSession(row));
  });
  
  return grouped;
};

/**
 * Get all unique courses (without duplicates)
 */
export const getUniqueCourses = (groupedData) => {
  return Object.values(groupedData).map(course => ({
    courseCode: course.courseCode,
    courseTitle: course.courseTitle,
    offerDept: course.offerDept,
    term: course.term,
    sections: Object.keys(course.sections),
    sectionCount: Object.keys(course.sections).length
  }));
};

/**
 * Check if two time slots overlap
 */
export const hasTimeConflict = (session1, session2) => {
  // Check if they share any day
  const days = ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun'];
  const sharedDays = days.filter(day => 
    session1.days[day] && session1.days[day].trim() !== '' && 
    session2.days[day] && session2.days[day].trim() !== ''
  );
  
  if (sharedDays.length === 0) return false;
  
  // Check time overlap
  const start1 = timeToMinutes(session1.startTime);
  const end1 = timeToMinutes(session1.endTime);
  const start2 = timeToMinutes(session2.startTime);
  const end2 = timeToMinutes(session2.endTime);
  
  if (start1 === null || end1 === null || start2 === null || end2 === null) {
    console.warn('Time parsing failed:', {
      session1: { 
        raw: { start: session1.startTime, end: session1.endTime },
        parsed: { start: start1, end: end1 }
      },
      session2: { 
        raw: { start: session2.startTime, end: session2.endTime },
        parsed: { start: start2, end: end2 }
      }
    });
    return false;
  }
  
  // Two time slots overlap if one starts before the other ends
  return start1 < end2 && start2 < end1;
};

/**
 * Check if two sections have time conflicts
 */
export const hasSectionConflict = (section1Sessions, section2Sessions) => {
  for (const session1 of section1Sessions) {
    for (const session2 of section2Sessions) {
      if (hasTimeConflict(session1, session2)) {
        return true;
      }
    }
  }
  return false;
};

/**
 * Generate all possible schedule combinations
 * 
 * Algorithm:
 * 1. Group courses by whether they're offered in one or both semesters
 * 2. For single-semester courses, assign to their offering semester
 * 3. Check if either semester already exceeds 6 courses from single-semester courses
 * 4. Permutate dual-semester courses across both semesters
 * 5. For each semester distribution, try all subclass combinations
 * 6. Check for time conflicts within each semester
 */
export const generateSchedules = (selectedCourses, groupedData) => {
  if (selectedCourses.length === 0) return [];
  
  const MAX_COURSES_PER_SEMESTER = 6;
  
  // Prepare course sections data
  const coursesWithSections = selectedCourses.map(course => ({
    courseCode: course.courseCode,
    courseTitle: course.courseTitle,
    term: course.term,
    sections: course.selectedSections.map(section => ({
      section,
      sessions: groupedData[course.courseCode].sections[section]
    }))
  }));
  
  console.log('Courses with sections for schedule generation:', coursesWithSections.map(c => ({
    course: c.courseCode,
    term: c.term,
    sectionCount: c.sections.length,
    sections: c.sections.map(s => ({
      section: s.section,
      sessionCount: s.sessions.length,
      sessions: s.sessions.map(sess => ({
        startDate: sess.startDate,
        endDate: sess.endDate,
        days: sess.days,
        startTime: sess.startTime,
        endTime: sess.endTime,
        startTimeFormatted: formatTime(sess.startTime),
        endTimeFormatted: formatTime(sess.endTime),
        venue: sess.venue,
        instructor: sess.instructor
      }))
    }))
  })));
  
  // Let me inspect one course in detail
  if (coursesWithSections.length > 0) {
    const firstCourse = coursesWithSections[0];
    console.log(`\n=== DETAILED INSPECTION: ${firstCourse.courseCode} ===`);
    firstCourse.sections.forEach(sec => {
      console.log(`\nSubclass: ${sec.section}`);
      sec.sessions.forEach((sess, idx) => {
        console.log(`  Session ${idx + 1}:`, {
          days: Object.entries(sess.days).filter(([day, val]) => val && val.trim() !== '').map(([day]) => day.toUpperCase()),
          rawStartTime: sess.startTime,
          rawEndTime: sess.endTime,
          startTimeType: typeof sess.startTime,
          isDateObject: sess.startTime instanceof Date,
          extractedStart: sess.startTime instanceof Date ? `${sess.startTime.getHours()}:${sess.startTime.getMinutes().toString().padStart(2, '0')}` : sess.startTime,
          extractedEnd: sess.endTime instanceof Date ? `${sess.endTime.getHours()}:${sess.endTime.getMinutes().toString().padStart(2, '0')}` : sess.endTime,
          dateRange: `${sess.startDate} to ${sess.endDate}`,
          venue: sess.venue,
          instructor: sess.instructor
        });
      });
    });
    console.log('=== END INSPECTION ===\n');
  }
  
  // Log semester distribution for debugging
  const semesterCounts = {};
  coursesWithSections.forEach(c => {
    semesterCounts[c.term] = (semesterCounts[c.term] || 0) + 1;
  });
  console.log('Selected courses per semester:', semesterCounts);
  console.log('Max allowed per semester in generated schedules:', MAX_COURSES_PER_SEMESTER);
  console.log('Note: Algorithm will generate valid schedules by selecting subsets if needed');
  
  // Generate all combinations recursively
  const results = [];
  let testedCount = 0;
  let conflictCount = 0;
  let semesterLimitCount = 0;
  
  const generateCombinations = (index, currentSchedule) => {
    if (index === coursesWithSections.length) {
      testedCount++;
      
      // Check semester course limits first (faster check)
      const bySemester = {};
      currentSchedule.forEach(item => {
        if (!bySemester[item.term]) {
          bySemester[item.term] = 0;
        }
        bySemester[item.term]++;
      });
      
      // Ensure no semester has more than MAX_COURSES_PER_SEMESTER courses
      const exceedsSemesterLimit = Object.values(bySemester).some(count => count > MAX_COURSES_PER_SEMESTER);
      
      if (exceedsSemesterLimit) {
        semesterLimitCount++;
        return;
      }
      
      // Check for time conflicts ONLY within the same semester
      let hasConflict = false;
      let conflictDetails = null;
      
      // Group courses by semester
      const coursesBySemester = {};
      currentSchedule.forEach(item => {
        if (!coursesBySemester[item.term]) {
          coursesBySemester[item.term] = [];
        }
        coursesBySemester[item.term].push(item);
      });
      
      // Check conflicts within each semester separately
      for (const term in coursesBySemester) {
        const coursesInSemester = coursesBySemester[term];
        
        for (let i = 0; i < coursesInSemester.length - 1; i++) {
          for (let j = i + 1; j < coursesInSemester.length; j++) {
            // Check if any session from course i conflicts with any session from course j
            for (const session1 of coursesInSemester[i].sessions) {
              for (const session2 of coursesInSemester[j].sessions) {
                if (hasTimeConflict(session1, session2)) {
                  hasConflict = true;
                  conflictDetails = {
                    term: term,
                    course1: coursesInSemester[i].courseCode,
                    section1: coursesInSemester[i].section,
                    course2: coursesInSemester[j].courseCode,
                    section2: coursesInSemester[j].section,
                    session1: session1,
                    session2: session2
                  };
                  break;
                }
              }
              if (hasConflict) break;
            }
            if (hasConflict) break;
          }
          if (hasConflict) break;
        }
        if (hasConflict) break;
      }
      
      if (hasConflict) {
        conflictCount++;
        if (conflictCount <= 3) {
          console.log(`Conflict #${conflictCount} detected in ${conflictDetails.term}:`, {
            course1: `${conflictDetails.course1}-${conflictDetails.section1}`,
            course2: `${conflictDetails.course2}-${conflictDetails.section2}`,
            session1: {
              days: Object.entries(conflictDetails.session1.days).filter(([k,v]) => v && v.trim()).map(([k]) => k.toUpperCase()),
              time: `${formatTime(conflictDetails.session1.startTime)}-${formatTime(conflictDetails.session1.endTime)}`
            },
            session2: {
              days: Object.entries(conflictDetails.session2.days).filter(([k,v]) => v && v.trim()).map(([k]) => k.toUpperCase()),
              time: `${formatTime(conflictDetails.session2.startTime)}-${formatTime(conflictDetails.session2.endTime)}`
            }
          });
        }
      }
      
      if (!hasConflict) {
        // Valid schedule found
        if (results.length === 0) {
          const bySemester = {};
          currentSchedule.forEach(item => {
            if (!bySemester[item.term]) {
              bySemester[item.term] = 0;
            }
            bySemester[item.term]++;
          });
          console.log('First valid schedule found:', currentSchedule.map(item => ({
            course: item.courseCode,
            section: item.section,
            term: item.term
          })));
          console.log('Semester distribution:', bySemester);
        }
        results.push(currentSchedule);
      }
      return;
    }
    
    const course = coursesWithSections[index];
    for (const sectionData of course.sections) {
      generateCombinations(index + 1, [
        ...currentSchedule,
        {
          courseCode: course.courseCode,
          courseTitle: course.courseTitle,
          term: course.term,
          section: sectionData.section,
          sessions: sectionData.sessions
        }
      ]);
    }
  };
  
  generateCombinations(0, []);
  
  console.log('Schedule generation statistics:', {
    totalTested: testedCount,
    conflictRejections: conflictCount,
    semesterLimitRejections: semesterLimitCount,
    validSchedules: results.length
  });
  
  if (results.length === 0) {
    console.error('❌ No valid schedules found!');
    if (semesterLimitCount > 0 && conflictCount === 0) {
      console.error('All combinations exceeded the 6-courses-per-semester limit');
    } else if (conflictCount > 0 && semesterLimitCount === 0) {
      console.error('All combinations had time conflicts within semesters');
    } else if (conflictCount > 0 && semesterLimitCount > 0) {
      console.error('Combinations failed due to both conflicts and semester limits');
    }
    console.error('Try:');
    console.error('1. Selecting different subclasses with different time slots');
    console.error('2. Reducing the number of courses selected');
  } else {
    console.log(`✅ Found ${results.length} valid schedule(s)!`);
  }
  
  // Sort results to prioritize balanced schedules
  results.sort((a, b) => {
    // Group by semester
    const getSemesterCounts = (schedule) => {
      const counts = {};
      schedule.forEach(item => {
        counts[item.term] = (counts[item.term] || 0) + 1;
      });
      return Object.values(counts).sort((x, y) => x - y);
    };
    
    const countsA = getSemesterCounts(a);
    const countsB = getSemesterCounts(b);
    
    // Calculate variance (lower is more balanced)
    const variance = (counts) => {
      const mean = counts.reduce((sum, c) => sum + c, 0) / counts.length;
      return counts.reduce((sum, c) => sum + Math.pow(c - mean, 2), 0) / counts.length;
    };
    
    return variance(countsA) - variance(countsB);
  });
  
  return results;
};

/**
 * Get date range for all sessions in a schedule
 */
export const getScheduleDateRange = (schedule) => {
  let minDate = null;
  let maxDate = null;
  
  schedule.forEach(course => {
    course.sessions.forEach(session => {
      const start = new Date(session.startDate);
      const end = new Date(session.endDate);
      
      if (!minDate || start < minDate) minDate = start;
      if (!maxDate || end > maxDate) maxDate = end;
    });
  });
  
  return { minDate, maxDate };
};

/**
 * Get week numbers for a date range
 */
export const getWeekNumbers = (minDate, maxDate) => {
  if (!minDate || !maxDate) return [];
  
  const weeks = [];
  const current = new Date(minDate);
  current.setDate(current.getDate() - current.getDay()); // Start from Sunday
  
  let weekNum = 1;
  while (current <= maxDate) {
    weeks.push({
      weekNumber: weekNum,
      startDate: new Date(current),
      endDate: new Date(current.getTime() + 6 * 24 * 60 * 60 * 1000)
    });
    current.setDate(current.getDate() + 7);
    weekNum++;
  }
  
  return weeks;
};

/**
 * Check if a session occurs in a specific week
 */
export const isSessionInWeek = (session, weekStart, weekEnd) => {
  const sessionStart = new Date(session.startDate);
  const sessionEnd = new Date(session.endDate);
  
  return sessionStart <= weekEnd && sessionEnd >= weekStart;
};

/**
 * Process raw data into structured course information
 */
export const processCoursesData = (rawData) => {
  console.log('Processing raw data, total rows:', rawData.length);
  console.log('Sample raw row:', rawData[0]);
  
  // Filter courses
  const filtered = filterCourses(rawData);
  console.log('After filtering:', filtered.length, 'rows');
  
  // Group by course and section
  const grouped = groupByCourseAndSection(filtered);
  console.log('Grouped courses:', Object.keys(grouped).length);
  
  // Get unique courses
  const courses = getUniqueCourses(grouped);
  console.log('Unique courses:', courses.length);
  
  return {
    courses: courses.sort((a, b) => a.courseCode.localeCompare(b.courseCode)),
    grouped,
    totalCourses: courses.length,
    totalSessions: filtered.length
  };
};
